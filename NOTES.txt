- To "bind" a driver to a backend device, the <device-id, pci-id> pair generated by QEMU backend (i.e. the device)
must be known to the driver while using MODULE_DEVICE_TABLE()

# STEP 1
/*
 * Read the config data for a PCI device, sanity-check it,
 * and fill in the dev structure.
 */
static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
- Given the pci_bus struct, the function creates pci_dev struct for each 
device detected on the pci bus via pci_setup_device().


// probe.c
int pci_setup_device(struct pci_dev *dev): at boot time, pci_dev structs are initialized for 
every device. (virtio--simple is [1af4:10f3] here)

vm@cs695:~/virtio-simple$ sudo dmesg | grep class
[sudo] password for vm: 
[    0.639750] pci 0000:00:00.0: [8086:1237] type 00 class 0x060000 conventional PCI endpoint
[    0.640630] pci 0000:00:01.0: [8086:7000] type 00 class 0x060100 conventional PCI endpoint
[    0.641815] pci 0000:00:01.1: [8086:7010] type 00 class 0x010180 conventional PCI endpoint
[    0.657726] pci 0000:00:01.3: [8086:7113] type 00 class 0x068000 conventional PCI endpoint
[    0.660563] pci 0000:00:02.0: [1234:1111] type 00 class 0x030000 conventional PCI endpoint
[    0.701168] pci 0000:00:03.0: [1af4:1000] type 00 class 0x020000 conventional PCI endpoint
[    0.720691] pci 0000:00:04.0: [1af4:10f3] type 00 class 0x00ff00 conventional PCI endpoint
[    0.745245] pci 0000:00:05.0: [1af4:1001] type 00 class 0x010000 conventional PCI endpoint


# STEP 2
pci_device_add() -> int device_add(struct device *dev) : device_add creates the syfs entries, device file etc.
pci_bus -> pci_dev
- The pci_dev struct contains pointer to driver, which for virtio-devices is set to the virtio-pci driver

# STEP 3
Look for a driver for this initialized device
bus_for_each_drv() : Each bus is assoc with a subsystem that has a set of loaded drivers (via bus to subsys)
__device_attach_driver() matches a driver based on vendor id and calls that driver's probe method. (aall virtio devices; using the 1af4 vendor id in table).

void bus_probe_device(struct device *dev) -> device_initial_probe -> __device_attach_driver -> call_driver_probe()
- This calls the probe method of the common pci driver. No virtio specific things are happening yet.
```
if (dev->bus->probe)
	ret = dev->bus->probe(dev);
```

# STEP 4
Call the COMMON virtio-pci probe function that is registed with the bus.

virtio_pci_common.c (driver virtio-pci)
/* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */
static const struct pci_device_id virtio_pci_id_table[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) },
	{ 0 }
};
a. 
 * Initialize device before it's used by a driver. Ask low-level code
 * to enable I/O and memory. Wake up the device if it was suspended.
 * Beware, this function can fail.
pci_enable_device()->do_pci_enable_device()

b. 
virtio_pci_modern_probe(): access the config space, capabilities etc.
```
notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,
					IORESOURCE_IO | IORESOURCE_MEM,
					&mdev->modern_bars);
```
- This 	finds an mmio address to send notifications via `mdev->notify_base`
Each device virtqueue has its own notification area starting at mdev->notify_base.
The above function maps a large-ish chunk to ensure any number of virtqueues (and notifs)
can be supported by the driver.
```
/**
 * pci_iomap_range - create a virtual mapping cookie for a PCI BAR
 * @dev: PCI device that owns the BAR
 * @bar: BAR number
 * @offset: map memory at the given offset in BAR
 * @maxlen: max length of the memory to map
 *
 * Using this function you will get a __iomem address to your device BAR.
 * You can access it using ioread*() and iowrite*(). These functions hide
 * the details if this is a MMIO or PIO address space and will just do what
 * you expect from them in the correct way.
 *
 * @maxlen specifies the maximum length to map. If you want to get access to
 * the complete BAR from offset to the end, pass %0 here.
 * */
- mapped via pci_iomap_range()
```
- this calls ioremap to return pointer to some area in a pci BAR.
- Note that in reality, the guest ends up mapping to an area in host heap that 
is allocated by QEMU.

c.
Assoicate a set of common virtio config ops with the virtio device
```
static const struct virtio_config_ops virtio_pci_config_ops = {
	.get		= vp_get,
	.set		= vp_set,
	.generation	= vp_generation,
	.get_status	= vp_get_status,
	.set_status	= vp_set_status,
	.reset		= vp_reset,
	.find_vqs	= vp_modern_find_vqs,
	.del_vqs	= vp_del_vqs,
	.synchronize_cbs = vp_synchronize_vectors,
	.get_features	= vp_get_features,
	.finalize_features = vp_finalize_features,
	.bus_name	= vp_bus_name,
	.set_vq_affinity = vp_set_vq_affinity,
	.get_vq_affinity = vp_get_vq_affinity,
	.get_shm_region  = vp_get_shm_region,
	.disable_vq_and_reset = vp_modern_disable_vq_and_reset,
	.enable_vq_after_reset = vp_modern_enable_vq_after_reset,
	.create_avq = vp_modern_create_avq,
	.destroy_avq = vp_modern_destroy_avq,
};
```

d.
Register the virtio device virtio_register_device(). Add the new virtio device to the "virtio" bus.
pci_bus (pci_device) -> virtio_bus (virtio_pci_device)

```
/*
	* device_add() causes the bus infrastructure to look for a matching
	* driver.
	*/
err = device_add(&dev->dev);
```

# STEP 5
Once the device specific driver is reg, the probe() is called (this is our simple-probe/etc)
- The virtio-pci funcs are thus made available to each virtio device via the config ops in 
struct virtio_pci_device
